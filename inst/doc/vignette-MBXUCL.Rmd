---
title: "MBXUCL package"
author: "Manon Martin"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{MBXUCL package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
require(knitr)
require(pander)
require(MBXUCL)


```

# Overview
This document provides a brief summary on how to use the MBXUCL library in R.

# Package installation

The library can be installed from a stand alone version contained in a personnal folder:
```{r install1, tidy=TRUE,  eval=FALSE}

install.packages(file.path("path to MBXUCL-package", "MBXUCL-package/MBXUCL"), repos = NULL, type="source")
require(MBXUCL)

```

Notes:

* Change the `path to MBXUCL-package`directory in `file.path` as it is in your computer
* Check for latest version of R and download additionnal required packages

Or it can be downloaded directly from Github:
```{r install2, tidy=TRUE,  eval=FALSE}
require(devtools)
install_github("ManonMartin/MBXUCL", dependencies = TRUE)
require(MBXUCL)

```




# Available tools

## Inertia measures

```{r inertia}
data("HumanSerum")
Inertia.res = MBXUCL::Inertia(x = HumanSerumSpectra, y = ClassHS, print = TRUE)

kable(Inertia.res[["Between_within"]])

kable(Inertia.res[["Per_group"]])
```


## PCA
```{r pca}
data("HumanSerum")
PCA.res = MBXUCL::SVDforPCA(HumanSerumSpectra, ncomp=4)
```

### Eigenvalues

```{r eigPCA}
pander(PCA.res[["eigval"]][1:4])
```

### Scores

```{r Scores}
pander(PCA.res[["scores"]][1:10,])
```

Draw scores:

```{r scoreplot, out.width='100%', fig.width=8, fig.height=8}

DrawScores(PCA.res, type.obj = "PCA", drawNames = TRUE,
  createWindow = FALSE, main = "PCA score plot for HumanSerum dataset", 
  color = ClassHS, size = 2, cex.lab = 4, axes = c(1, 2), 
  drawEllipses = TRUE, typeEl = "norm", levelEl = 0.9)

```


### Loadings

```{r Loadings}
pander(PCA.res[["loadings"]][1:10,])
```

Draw loadings:
* First option
```{r, out.width='100%', fig.width=8, fig.height=6}

DrawLoadings(obj = PCA.res, type.obj = "PCA",
  createWindow = FALSE, main = "PCA loadings plot for HumanSerum dataset", 
  axes = c(1, 2), loadingstype = "l", num.stacked = 4,  ang = "0", xaxis_type = "numerical",
  nxaxis = 10, xlab = "ppm")
```

* Second option
```{r, out.width='100%', fig.width=8, fig.height=6}
DrawLoadings(obj = PCA.res, type.obj = "PCA",
  createWindow = FALSE, main = "PCA loadings plot for HumanSerum dataset", 
  axes = c(1, 2), loadingstype = "s", num.stacked = 4,  ang = "0", xaxis_type = "numerical",
  nxaxis = 10, xlab = "ppm")
```

* Third option
```{r, out.width='100%', fig.width=8, fig.height=6}
DrawLoadings(obj = PCA.res, type.obj = "PCA",
  createWindow = FALSE, main = "PCA loadings plot for HumanSerum dataset", 
  axes = c(1, 2), loadingstype = "p", num.stacked = 4,  ang = "0", xaxis_type = "numerical",
  nxaxis = 10, xlab = "ppm")
```

## Unsupervised clustering


### Unsupervised clustering on (GPL) intensities and associated MIC indexes


```{r ClustMIC, out.width='100%', fig.width=12, fig.height=12}
data("HumanSerum")
ClustMIC.res = MBXUCL::ClustMIC(Intensities = HumanSerumSpectra, nClust = 4, Trcl = ClassHS, Dendr = TRUE)

pander(ClustMIC.res)
```


### Unsupervised clustering on (GPL) binary presence/absence of peaks and associated MIC indexes


```{r binClustMIC, out.width='100%', fig.width=12, fig.height=12}
Pos = t(GPL[, seq(4,dim(GPL)[2], 2)])
Trcl = c(rep(1,8), rep(2,8), rep(3,8))
binClustMIC.res = MBXUCL::binClustMIC(Positions = Pos, Distance = "Jaccard", nClust = 3, Trcl, Dendr = TRUE)

pander(binClustMIC.res)
```

## PLS-DA 

```{r PLSDA, out.width='100%', fig.width=10, fig.height=10}
data("HumanSerum")
Class = ClassHS
PLSDA.res = PLSDA(x = HumanSerumSpectra, y = Class, nLV = NULL, drawRMSEP = TRUE)

perf.plsda = PLSDA.res[4:6]
pander(perf.plsda)
```



### Scores and loadings plots (with mannually defined colors and pch)
  
```{r, out.width='100%', fig.width=8, fig.height=8}

DrawScores(obj = PLSDA.res, type.obj = "PLSDA", drawNames = TRUE,
  createWindow = FALSE, main = "PLSDA score plot for HumanSerum dataset",
  color = Class, pch = Class, size = 2, cex.lab = 4, axes = c(1, 2), 
  drawEllipses = TRUE, typeEl = "norm", levelEl = 0.9,
  legend_color_manual = c("1"="blue", "2"="green3", "3" = "black", 
                          "4" = "yellow"),
  legend_shape_manual = c("1"= 0, "2"= 6, "3" = 3, "4" = 4))

DrawLoadings(obj = PLSDA.res, type.obj = "PLSDA",
  createWindow = FALSE, main = "PLSDA loadings plot for HumanSerum dataset", 
  axes = c(1, 2, 3), loadingstype = "l", num.stacked = 4,  ang = "0", xlab = "ppm",
  xaxis_type = "numerical", nxaxis = 10)

```



## OPLS-DA


```{r OPLSDA}

data("DataSimul")
x = DataSimul[["x"]]
y = DataSimul[["y"]]
m = dim(x)[2]
no=3
nb = 15
oplsda.res = OPLSDA(x=x, y=y, impT = FALSE,impG = FALSE, no=no, nb = nb)


```


  
  
  
### Choice of the number of orthogonal components

Eigenvalue criterion in Trygg (2001):
```{r , out.width='70%',fig.width=8, fig.height=8}
COL=rep("gray93",no)
mp=barplot(oplsda.res$CV,
           axes=F, axisnames=F, border=1,col=COL)
axis(1,at=mp, labels=c(1:no))
axis(2)
title(main="OPLS: Choice of the n[orthog. Components]", xlab="Orthogonal OPLS-DA Components",   ylab="||Wortho|| / ||p||", cex.main = 0.8)

```


Or by cross-validation:
  
  
```{r, out.width='70%', fig.width=8, fig.height=8, eval=FALSE}
cvOPLSDA.res = cvOPLSDA(x = x, y = y, k_fold = 10, NumOrtho = 10)
plot(1:length(cvOPLSDA.res$RMSECV), cvOPLSDA.res$RMSECV, main = "RMSECV", lty = 19)

```


### Scores and loadings plots
  
```{r, out.width='100%', fig.width=8, fig.height=8}
Class = y

DrawScores(obj = oplsda.res, type.obj = "OPLSDA", drawNames = FALSE,
  createWindow = FALSE, main = "PLSDA score plot for DataSimul dataset", 
  color = Class, size = 2, cex.lab = 4, axes = c(1, 2), 
  drawEllipses = TRUE, typeEl = "norm", levelEl = 0.9)

DrawLoadings(obj = oplsda.res, type.obj = "OPLSDA",
  createWindow = FALSE, main = "PLSDA loadings plot for DataSimul dataset", 
  axes = c(1, 2, 3), loadingstype = "l", num.stacked = 4,  ang = "0", xlab = "ppm",
  xaxis_type = "numerical", nxaxis = 10)


```


### S-plot


```{r, out.width='100%', fig.width=8, fig.height=7}

# S-plot
###########################
## correlation and covariance matrices
# covariance
s = as.matrix(x, ncol = ncol(x))
p1 = c()
for (i in 1:ncol(s)) {
  scov = cov(s[, i], oplsda.res$Tp)
  p1 = matrix(c(p1, scov), ncol = 1) # covariance x-T
}

# correlation
pcorr1 = c()
Tno=as.matrix(oplsda.res$Tp, ncol=1)
for (i in 1:nrow(p1)) {
  den = apply(Tno, 2, sd, na.rm = TRUE) * sd(s[, i])
  corr1 = p1[i, ]/den
  pcorr1 = matrix(c(pcorr1, corr1), ncol = 1) # correlation
}

# plot

plot(p1, pcorr1, xlab = "p(cov)[1]", ylab = "p(corr)[1]",
     main = "S-plot (OPLS-DA)", ylim=c(min(pcorr1, na.rm = T)*1.1,
                                       max(pcorr1, na.rm = T)*1.1), 
     xlim=c(min(p1, na.rm = T)*1.1, max(p1, na.rm = T)*1.1))

sel = p1*pcorr1
sel = order(sel, decreasing = TRUE)[1:nb]
text(p1[sel], pcorr1[sel], labels = colnames(s)[sel], cex = 1, pos = 1)
abline(v=0,lty = 2)
abline(h=0,lty = 2)



```



### Model coefficients

```{r, out.width='100%', fig.width=12, fig.height=5}

delta=mean(sort(abs(oplsda.res$b))[m-nb+c(0,1)])
xax = as.numeric(names(oplsda.res$b))

par(mar=c(4,2,2,1))
plot(oplsda.res$b,type="l",xaxt = "n", yaxt = "n", main="OPLS: Vector of descriptors' rank",xlab="ppm" )
abline(h=0)
abline(h=delta*c(-1,1),lty=2)
axis(side=2,cex.axis=1)
axis(side=1,at=c(1,seq(50,m,50)), labels=xax[c(1,seq(50,m,50))])

```


### Prediction of new observations

```{r}
xtrain = x[-c(1:5),]
ytrain = y[-c(1:5)]
xnew = x[c(1:5),]
oplsda.res = OPLSDA(x=xtrain, y=ytrain,
                    impT = FALSE,impG = FALSE, no=2, nb = 15, out.path = ".")
OPLSDA_pred(ropls = oplsda.res, x.new = xnew)


```


## Other Drawing functions


```{r}
data(iris)
rownames(iris) <- paste0("iris", 1:dim(iris)[1])
dataset <- iris[sample(150, 20),1:4]
dataset <- t(dataset)
```


### LinePlot

```{r, out.width='100%', fig.width=6, fig.height=6}

LinePlot(X = dataset, createWindow = FALSE, 
         main = "Iris' sepal and petal profiles",  rows = c(1:4),
             type = "p", num.stacked = 4, xlab = "Iris", ylab = "Variables",
             ang = "90", xaxis_type = "character", nxaxis = 20)


```



### ScatterPlot

```{r, out.width='100%', fig.width=7, fig.height=9}

a <- ScatterPlot(x = iris$Sepal.Length, y = iris$Petal.Length, 
                 points_labs = rownames(iris), createWindow = FALSE, 
                 main = "Length of iris' petals and sepals", color = iris$Species, 
                 pch = iris$Species, size = 2, cex.lab = 3, xlab = NULL, ylab = NULL, 
                 legend_pch = NULL, legend_color = NULL, drawEllipses = TRUE, 
                 typeEl = "norm", levelEl = 0.9)

b <- ScatterPlot(x = iris$Sepal.Width, y = iris$Petal.Width, points_labs = rownames(iris), 
            createWindow = FALSE, main = "Width of iris' petals and sepals", 
            color = iris$Species,  pch = iris$Species, size = 2, cex.lab = 3, 
            xlab = NULL, ylab = NULL, legend_pch = NULL, legend_color = NULL, 
            drawEllipses = TRUE, typeEl = "norm", levelEl = 0.9)


require(gridExtra)
do.call(gridExtra::grid.arrange, c(list(a,b), list(nrow = 2, ncol = 1)))
```

